								服务器模型的变迁

从古至今，web服务器的架构经历了几次变迁。服务器处理客户端请求的并发量，就是每个里程碑的见证。

1.石器时代：同步
  最早的服务器，其执行模型是同步的，他的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味着除了当前的请求被处理外，其余请求都处于耽误的状态。他的处理能力相当低下。这类架构如今已被淘汰，只存在于一些对并发无要求的应用中。

2.青铜时代：复制过程
  为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接要启动100个进程来服务，这样是非常昂贵的代价。在复制的过程中，需要复制进程内部的状态，对每个连接都进行这样的复制的话，相同的状态在内存中存在很多分，造成浪费，并且这个过程由于要复制较多的数据，启动是较为缓慢的。
  为了解决启动慢的问题，预复制(prefork)被引入服务模型中，即预先复制一定数量的进程，同时将进程复用，避免进程创建，销毁带来的开销。但是这个模型没有伸缩性，一旦并发请求过高，内存会随着进程数的增长被耗尽。
  假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N。

3.白银时代：多线程
  为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求，线程相对进程的开销要小很多，并且线程之间可以共享数据，内存浪费的问题得以解决，并且利用线程池可以减少创建和销毁线程的开销，但是多线程面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心，在一个时刻只能做一件事情，操作系统只能将CPU切分为时间片的方法，让线程可以较为均匀的使用CPU资源，但是操作系统在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被浪费在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。

4.黄金时代：事件驱动
  多进程，每个进程只有一个线程，避免了不必要的内存消耗和上下文切换的开销，当注册的事件发生时，该线程开始执行回调函数。




  

