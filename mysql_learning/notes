create table Users
(
	// 列明     类型     约束
	user_uuid varchar(50) unique primary key,
	email_address varchar(150) unique,

	display_name varchar(100) not null,
	password varchar(100),

	first_seen_data bigint,
	last_modified_date bigint,

	deleted bool default false,



	//索引
	index(email_address),
	index(user_uuid)
)
//执行引擎
engine = InnoDB;


引擎：
数据库中的存储引擎其实是对使用了该引擎的表进行某种设置，数据库中的表设定了什么存储引擎，那么该表在数据存储方式、数据更新方式、数据查询性能以及是否支持索引等方面就会有不同的“效果”。

ISAM，MYISAM，HEAP，InnoDB

ISAM:该引擎在读取数据方面速度很快，而且不占用大量的内存和存储资源；但是ISAM不支持事务处理、不支持外来键、不能够容错、也不支持索引。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持

MYISAM:该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的索引等大量功能.......

HEAP:  该存储引擎通过在内存中创建临时表来存储数据.所以使用该种引擎的表拥有极高的插入、更新和查询效率,这种存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的生命周期很短，一般只使用一次.

InnoDB:该存储引擎为MySQL表提供了ACID事务支持.


事物：所谓事务就是针对数据库的一组操作，它可以由一条或者多条SQL语句组成，同一个事务的操作具备同步的特点，如果其中有一条语句不能执行的话，那么所有的语句都不会执行，也就是说，事务中的语句要么都执行，要么都不执行

ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

（1）原子性： 原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。

（2）一致性：一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。我的理解：我和小明总共有200块钱，其中我有150块钱，小明有50块钱，如果我给小明了50块钱，那么一致性就是说即使我给了小明50块钱，这个时候我有100，小明有100，但是我们的总和还是200，总和不能减少，也不能增加。

（3）隔离性：隔离性是指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被企图进行修改的事务看到 。（多进程）

（4）持久性：持久性是指在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。


隔离性级别：
·未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
     事物1                              事物2
     开始                               开始
     读取a = 3

     修改a = 4                          读取a = 4(出现脏读)                       
                                                 
     出错（回滚）                       
     a = 3

怎么解决？：必须等一个事物提交了成功提交了修改的数据以后，才允许其他事物进行读取

·提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)

    事物1                             事物2
    
    开始                              开始
    读取a = 3

    修改a = 4

    出错(回滚)
    a = 3
    结束                              成功读取a = 3


那么如果遇到如下情况：
    事物1                               事物2
    开始                                开始
    读取a = 3                           

                                        修改a = 4
					
					结束
     读取a = 4(两次读取结果不一样了)

问题：两次读取的结果不一样了，怎么解决：就是在开始读取数据（事务开启）时，不再允许修改操作
·重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
	事物1                           事物2
        开始                            开始
        读取a = 3                       修改a = 4，但是不允许，阻塞
        ...
        读取a = 3
        结束                             
                                        成功修改a = 4
                                        结束
如果事物2并不修改a = 3，它直接删除数据呢？
      事物1                                 事物2
      开始                                  开始
      读取a = 3                             删除a
      ...
      读取不到，消失了，出现了（幻读）
      结束                                  结束
怎么解决？ 序列化：是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用

      事物1
      开始
      随便怎么操作
      结束
                                           事物2
                                           开始
                                           。。。
                                           结束
事物的详细解释：http://blog.csdn.net/qq_33290787/article/details/51924963 ，以下为链接的复制内容


数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。

Read uncommitted

读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。

事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。

Read committed

读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…

分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。

那怎么解决可能的不可重复读问题？Repeatable read ！

Repeatable read

重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

什么时候会出现幻读？

事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

那怎么解决幻读问题？Serializable！

Serializable 序列化

Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。








数据库的索引：

